<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title>My fist three.js app</title>
	<style>
		body {
			margin: 0;
		}
	</style>
</head>

<body>
	<script type="module">
		import * as THREE from 'https://unpkg.com/three/build/three.module.js';
		//import { OrbitControls } from '../js/examples/jsm/controls/OrbitControls.js';
		//var controls = undefined;
		let loader = new THREE.TextureLoader();
		let texture_floor = loader.load('https://threejsfundamentals.org/threejs/resources/images/wall.jpg');
		let texture = loader.load('./opacity.png')
		let texturep1 = loader.load('./xrenoux.jpg')
		//let texture_floor = loader.load('./abelhadi.jpg');
		let texturep2 = loader.load('./beaudibe.jpg');
		let ball_starting_speed = 0.03;
		let ball_speed = ball_starting_speed;
		let ball_x = 0;
		let ball_y = 0;
		let ball_z = 0;
		let ball_pause = 0;
		let ball_acc = 1.3;
		let stage_radius = 5;
		let ball_radius = .5;
		let ball_rotation_z =1;
		let ball_bounces = 0;
		let nb_players = 5;
		let player_width = .3;
		let scores = [nb_players];
		let player_speed = 0.1;
		let player1_direction = 0;
		let player2_direction = 0;
		let players_size = (Math.PI /2) *1.5;
		let player_angle =players_size / (nb_players +1)
		function create_player(colorisation)
		{
			const geometry = new THREE.RingGeometry( stage_radius, stage_radius+ player_width, 32 ,10, -player_angle /2, player_angle);
			const material = new THREE.MeshBasicMaterial({ color: colorisation});
			const shapePoints = geometry.attributes.position.array;
			const shape = new THREE.Shape();
			shape.moveTo(shapePoints[0], shapePoints[1]);
			for (let i = 3; i < shapePoints.length; i += 3) {
   			shape.lineTo(shapePoints[i], shapePoints[i + 1]);
		}
		shape.lineTo(shapePoints[0], shapePoints[1]); // Close the shape
/*ExtrudeGeometry(shapes : Array, options : Object)

shapes — Shape or an array of shapes.
options — Object that can contain the following parameters.

    curveSegments — int. Number of points on the curves. Default is 12.
    steps — int. Number of points used for subdividing segments along the depth of the extruded spline. Default is 1.
    depth — float. Depth to extrude the shape. Default is 1.
    bevelEnabled — bool. Apply beveling to the shape. Default is true.
    bevelThickness — float. How deep into the original shape the bevel goes. Default is 0.2.
    bevelSize — float. Distance from the shape outline that the bevel extends. Default is bevelThickness - 0.1.
    bevelOffset — float. Distance from the shape outline that the bevel starts. Default is 0.
    bevelSegments — int. Number of bevel layers. Default is 3.
    extrudePath — THREE.Curve. A 3D spline path along which the shape should be extruded. Bevels not supported for path extrusion.
    UVGenerator — Object. object that provides UV generator functions
*/
// Define extrude settings
		const extrudeSettings = {
		extrudePath: new THREE.LineCurve3(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1)), // Set the extrude path
    	depth: 2 * ball_radius, // Set the depth to twice the ball radius for thickness
    	bevelEnabled: false // Disable beveling
		};

		// Extrude the shape
		const extrudedGeometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);

		// Create a mesh with the extruded geometry
		const p1_real_Mesh = new THREE.Mesh(extrudedGeometry, material);
		return p1_real_Mesh;
		}
		class Player{
            constructor(x) {
				if (x>1) {
					this.mesh = create_player(0xff0000);
				}
				else if (x)
				{
					this.mesh = create_player(0x00ff00);
				}
				else
				{
					this.mesh = create_player(0x0000ff);
				}
				this.hit = 0;
				scene.add(this.mesh);
				this.mesh.rotation.z = Math.PI *2 / nb_players * x;
				this.last_hit = 0;
            }
            setPosition(x, y, z) {
                this.mesh.position.set(x, y, z);
            }

            
        }
		// Our Javascript will go here.
		const scene = new THREE.Scene();
		const ground_geometry = new THREE.CircleGeometry(stage_radius,1012);
		const ground_material = new THREE.MeshBasicMaterial({ map: texture_floor });
		const ground = new THREE.Mesh(ground_geometry, ground_material);
		scene.add(ground);

		const camera = new THREE.PerspectiveCamera(75, window.innerWidth /
			window.innerHeight, 0.1, 1000);
		const renderer = new THREE.WebGLRenderer();
		camera.lookAt(new THREE.Vector3(0, 0, 0));
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);
		const ball_form = new THREE.SphereGeometry(ball_radius, 32, 32);

	for (let i = 0; i < nb_players; i++) {
			scores[i] = 0;
		}


		
		const ball_material = new THREE.MeshBasicMaterial({ map: texture });
		const ball_render = new THREE.Mesh(ball_form, ball_material);
		scene.add(ball_render);
		ball_render.position.z = ball_radius;
		let ball_angle = Math.random() * (Math.PI);

	//	controls = new OrbitControls( camera, renderer.domElement );
		const players = [];
		for (let i = 0; i < nb_players; i++) {
			players.push(new Player(i));
		}

		function ball_reset() {
			ball_x = Math.random(stage_radius- ball_radius*2) - stage_radius / 2 + ball_radius;
			ball_y = Math.random(stage_radius - ball_radius*2) - stage_radius / 2 + ball_radius;
			ball_speed = ball_starting_speed;
			ball_angle = Math.random() * (Math.PI);
			let hitters = 0;
			for (let i =0; i<nb_players; i++)
			{
				if (players[i].last_hit)
					hitters++;
			}
			if (hitters)
			{
			console.log("Points marques : " +ball_bounces + " a diviser entre "+ hitters + " joueurs");
				hitters = Math.trunc(ball_bounces / hitters)
				for (let i =0; i<nb_players; i++)
				{
					if (players[i].last_hit)
					{
						scores[i] += hitters;
						console.log("Joueur " + i + " a marque " + hitters + " points");
						players[i].last_hit = 0;
					}
				}
			}
			
			console.log("Remise en jeu ....");
			for (let i =0; i<nb_players; i++)
			{
				console.log("Joueur " + i + " a " + scores[i] + " points")
			}
			ball_pause = 30;
			ball_bounces = 0;
		}

		function calculateReflectionAngle(ball_x, ball_y, stage_radius, ball_radius,  ball_angle,collision_angle){
    let normal_angle = collision_angle + Math.PI / 2;

    let ball_vector_x = Math.cos(ball_angle);
    let ball_vector_y = Math.sin(ball_angle);

    let angle_between = Math.atan2(ball_vector_y, ball_vector_x) - normal_angle;
    return normal_angle - angle_between +(0.5-Math.random()) * (Math.PI/16);
}
		function normalize_angle(angle){
			angle = angle % (Math.PI*2);
			if (angle < -Math.PI)
				angle += Math.PI*2;
			if (angle > Math.PI)
				angle -= Math.PI*2;
			return angle;
		}
		function ball_hit(angle){
			let hit =0;
			let player_real_angle ;
			let player_max_angle;
			let player_min_angle;
			for(let i = 0; i<nb_players; i++){
				player_real_angle = normalize_angle(players[i].mesh.rotation.z - Math.PI / 2) ;
				player_max_angle = normalize_angle(player_real_angle + player_angle / 2);
				player_min_angle = normalize_angle(player_real_angle - player_angle / 2);
				if (players[i].hit)
				{	
					if (i >1)
						players[i].mesh.material.color.setHex(0xff0000);
					else if (i)
						players[i].mesh.material.color.setHex(0x00ff00);
					else
						players[0].mesh.material.color.setHex(0x0000ff);
					players[i].hit = 0;
					players[i].last_hit = 1;
				continue;
			}
				players[i].last_hit = 0; 
				if ((angle > player_min_angle && (angle < player_max_angle  || player_max_angle < player_min_angle)) || (angle < player_max_angle && (angle > player_min_angle || player_max_angle < player_min_angle)))
				{
					players[i].hit = 1;
					if (i > 1)
						players[i].mesh.material.color.setHex(0xbf0000);
					else if (i)
						players[i].mesh.material.color.setHex(0x00bf00);
					else
						players[0].mesh.material.color.setHex(0x0000bf);
					hit = 1;
				}

			}
			return hit;
		}

		function ball_move() {
			ball_render.position.x = ball_x;
			ball_render.position.y = ball_y;
			if (ball_pause) {
				ball_pause--;
				return;
			}

			ball_x += ball_speed * Math.cos(ball_angle);
			ball_y += ball_speed * Math.sin(ball_angle);
			if (ball_x *ball_x + ball_y * ball_y > (stage_radius-ball_radius) * (stage_radius-ball_radius)) {
				ball_bounces ++;
				let collision_angle = Math.atan2(ball_y, ball_x);
				console.log("Valeur du point : " + ball_bounces )
				if (ball_hit(collision_angle))
				{
				ball_angle = calculateReflectionAngle(ball_x, ball_y, stage_radius, ball_radius, ball_angle,collision_angle);
				ball_speed *= ball_acc;}
				else {
					
					ball_reset();}
			}
			//ball_reset();

		}
		function handleKeyDown(event) {
  		if (event.keyCode === 87) { 
    		player1_direction = +1;
			}
		if (event.keyCode === 83) {
			player1_direction = -1;
			}
		if (event.keyCode === 38) {
			player2_direction = -1;
			}
		if (event.keyCode === 40) {
			player2_direction = 1;
			}
			//on prend aussi gauche/droite
		if (event.keyCode === 37) {
			player2_direction = -1;
			}
		if (event.keyCode === 39) {
			player2_direction = 1;
			}
		//et les touches a et d
		if (event.keyCode === 65) {
			player1_direction = -1;
			}
		if (event.keyCode === 68) {
			player1_direction = 1;
			}


		}

		function handleKeyUp(event) {
			if (event.keyCode === 87 || event.keyCode === 83 ||  event.keyCode === 65 || event.keyCode === 68) {
				player1_direction = 0;
			}
			if (event.keyCode === 38 || event.keyCode === 40 || event.keyCode === 37 || event.keyCode === 39) {
				player2_direction = 0;
			}
  		}

		window.addEventListener('keydown', handleKeyDown, false);
		window.addEventListener('keyup', handleKeyUp, false);
		function player_move() {

			if (player1_direction) {
				//le joueur se deplace en faisant une rotation autour du point 0,0
				players[0].mesh.rotation.z+=(player1_direction * player_speed);
			}		
			if (player2_direction) {
				players[1].mesh.rotation.z+=(player2_direction * player_speed);
			}
			
		}
		//camera.position.x = 5;
		//camera.position.y = 5;
		camera.position.z = 10;
		camera.lookAt(new THREE.Vector3(0, 0, 0));
		//camera.rotateZ(Math.PI / 2);
	//	camera.rotation.set(Math.PI / -2, 0, 0);
		ground.position.z = 0;
		ball_reset();
		function animate() {
			requestAnimationFrame(animate);
		//	ball_render.rotation.z += (Math.abs(ball_y_speed) + Math.abs(ball_x_speed))* ball_rotation_z ;
	//		ball_render.rotation.y += ball_x_speed * 2;
	//		ball_render.rotation.x += ball_y_speed * 2;
			ball_move();
			player_move();
			for (let i = 2; i < nb_players; i++) {
				if (i%2)
					players[i].mesh.rotation.z += player_speed / 4;
				else
					players[i].mesh.rotation.z -= player_speed / 4;
			}
			renderer.render(scene, camera);
		}
		animate();
		
	</script>
</body>

</html>